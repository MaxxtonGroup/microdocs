{"version":3,"file":"config.js","sourceRoot":"","sources":["../../../../../modules/@angular/router/src/config.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAyQH,+BAA+B,MAAoB;IACjD,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;AAC/B,CAAC;AAED,sBAAsB,KAAY;IAChC,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,IAAI,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC3C,MAAM,IAAI,KAAK,CACX,mCAAmC,KAAK,CAAC,IAAI,oDAAoD,CAAC,CAAC;IACzG,CAAC;IACD,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,IAAI,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;QAC5C,MAAM,IAAI,KAAK,CACX,mCAAmC,KAAK,CAAC,IAAI,qDAAqD,CAAC,CAAC;IAC1G,CAAC;IACD,EAAE,CAAC,CAAC,KAAK,CAAC,UAAU,KAAK,SAAS,IAAI,CAAC,KAAK,CAAC,SAAS,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC1E,MAAM,IAAI,KAAK,CACX,mCAAmC,KAAK,CAAC,IAAI,qDAAqD,CAAC,CAAC;IAC1G,CAAC;IACD,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;QAC7B,MAAM,IAAI,KAAK,CAAC,8DAA8D,CAAC,CAAC;IAClF,CAAC;IACD,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/B,MAAM,IAAI,KAAK,CACX,yCAAyC,KAAK,CAAC,IAAI,mCAAmC,CAAC,CAAC;IAC9F,CAAC;IACD,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE,IAAI,KAAK,CAAC,UAAU,KAAK,SAAS;QACnD,CAAC,KAAK,CAAC,QAAQ,KAAK,SAAS,IAAI,KAAK,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC;QACpE,MAAM,GAAG,GACL,sFAAsF,CAAC;QAC3F,MAAM,IAAI,KAAK,CACX,iDAAiD,KAAK,CAAC,IAAI,mBAAmB,KAAK,CAAC,UAAU,oCAAoC,GAAG,EAAE,CAAC,CAAC;IAC/I,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\n\n/**\n * `RouterConfig` is an array of route configurations. Each one has the following properties:\n *\n * - *`path`* is a string that uses the route matcher DSL.\n * - `pathMatch` is a string that specifies the matching strategy.\n * - `component` is a component type.\n * - `redirectTo` is the url fragment which will replace the current matched segment.\n * - `outlet` is the name of the outlet the component should be placed into.\n * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See {@link\n * CanActivate} for more info.\n * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See {@link\n * CanDeactivate} for more info.\n * - `data` is additional data provided to the component via `ActivatedRoute`.\n * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more\n * info.\n * - `children` is an array of child route definitions.\n *\n * ### Simple Configuration\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: 'user/:name',\n *       component: User\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/bob`, the router will create the team component with the user\n * component in it.\n *\n * ### Multiple Outlets\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * },\n * {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: aux\n * }]\n * ```\n *\n * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to\n * the chat component. The chat component will be placed into the aux outlet.\n *\n * ### Wild Cards\n *\n * ```\n * [{\n *   path: '**',\n *   component: Sink\n * }]\n * ```\n *\n * Regardless of where you navigate to, the router will instantiate the sink component.\n *\n * ### Redirects\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: 'legacy/user/:name',\n *       redirectTo: 'user/:name'\n *     },\n *     {\n *       path: 'user/:name',\n *       component: User\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to '/team/11/legacy/user/jim', the router will change the url to\n * '/team/11/user/jim', and then will instantiate the team component with the user component\n * in it.\n *\n * If the `redirectTo` value starts with a '/', then it is a global redirect. E.g., if in the\n * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.\n *\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not \"consume\"\n * any url segments. Let's look at the following configuration:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: '',\n *       component: AllUsers\n *     },\n *     {\n *       path: 'user/:name',\n *       component: User\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to `/team/11`, the router will instantiate the AllUsers component.\n *\n * Empty-path routes can have children.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [\n *     {\n *       path: '',\n *       component: WrapperCmp,\n *       children: [\n *         {\n *           path: 'user/:name',\n *           component: User\n *         }\n *       ]\n *     }\n *   ]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with\n * the user component in it.\n *\n * ### Matching Strategy\n *\n * By default the router will look at what is left in the url, and check if it starts with\n * the specified path (e.g., `/team/11/user` starts with `team/:id`).\n *\n * We can change the matching strategy to make sure that the path covers the whole unconsumed url,\n * which is akin to `unconsumedUrl === path` or `$` regular expressions.\n *\n * This is particularly important when redirecting empty-path routes.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * },\n * {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * Since an empty path is a prefix of any url, even when navigating to '/main', the router will\n * still apply the redirect.\n *\n * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to\n * '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * },\n * {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * It is useful at times to have the ability to share parameters between sibling components.\n *\n * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both\n * of them require some id parameter.\n *\n * One way to do that would be to have a bogus parent component, so both the siblings can get the id\n * parameter from it. This is not ideal. Instead, you can use a componentless route.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux\n * child components next to each other. In this example, the application component\n * has to have the primary and aux outlets defined.\n *\n * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into\n * the `params`, `data`, and `resolve` of the children.\n *\n * This is especially useful when child components are defined as follows:\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * With this configuration in place, navigating to '/parent/10' will create the main child and aux\n * components.\n *\n * @stable\n */\nexport type RouterConfig = Route[];\n\n/**\n * See {@link RouterConfig} for more details.\n * @stable\n */\nexport type Data = {\n  [name: string]: any\n};\n\n/**\n * See {@link RouterConfig} for more details.\n * @stable\n */\nexport type ResolveData = {\n  [name: string]: any\n};\n\n/**\n * See {@link RouterConfig} for more details.\n * @stable\n */\nexport interface Route {\n  path?: string;\n\n  /**\n   * @deprecated - use `pathMatch` instead\n   */\n  terminal?: boolean;\n  pathMatch?: 'full'|'prefix';\n  component?: Type|string;\n  redirectTo?: string;\n  outlet?: string;\n  canActivate?: any[];\n  canDeactivate?: any[];\n  data?: Data;\n  resolve?: ResolveData;\n  children?: Route[];\n}\n\nexport function validateConfig(config: RouterConfig): void {\n  config.forEach(validateNode);\n}\n\nfunction validateNode(route: Route): void {\n  if (!!route.redirectTo && !!route.children) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': redirectTo and children cannot be used together`);\n  }\n  if (!!route.redirectTo && !!route.component) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': redirectTo and component cannot be used together`);\n  }\n  if (route.redirectTo === undefined && !route.component && !route.children) {\n    throw new Error(\n        `Invalid configuration of route '${route.path}': component, redirectTo, children must be provided`);\n  }\n  if (route.path === undefined) {\n    throw new Error(`Invalid route configuration: routes must have path specified`);\n  }\n  if (route.path.startsWith('/')) {\n    throw new Error(\n        `Invalid route configuration of route '${route.path}': path cannot start with a slash`);\n  }\n  if (route.path === '' && route.redirectTo !== undefined &&\n      (route.terminal === undefined && route.pathMatch === undefined)) {\n    const exp =\n        `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n    throw new Error(\n        `Invalid route configuration of route '{path: \"${route.path}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}