{"version":3,"file":"test_component_builder.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/testing/test_component_builder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationEntryMetadata, Compiler, ComponentFactory, Injectable, Injector, NgZone, OpaqueToken, ViewMetadata} from '../index';\nimport {PromiseWrapper} from '../src/facade/async';\nimport {ConcreteType, IS_DART, Type, isPresent} from '../src/facade/lang';\n\nimport {ComponentFixture} from './component_fixture';\nimport {tick} from './fake_async';\n\n\n\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @experimental\n */\nexport class TestComponentRenderer {\n  insertRootElement(rootElementId: string) {}\n}\n\n/**\n * @experimental\n */\nexport var ComponentFixtureAutoDetect = new OpaqueToken('ComponentFixtureAutoDetect');\n\n/**\n * @experimental\n */\nexport var ComponentFixtureNoNgZone = new OpaqueToken('ComponentFixtureNoNgZone');\n\nvar _nextRootElementId = 0;\nexport class TestComponentBuilder {\n  constructor(protected _injector: Injector) {}\n\n  /**\n   * Overrides only the html of a {@link ComponentMetadata}.\n   * All the other properties of the component's {@link ViewMetadata} are preserved.\n   */\n  overrideTemplate(componentType: Type, template: string): TestComponentBuilder {\n    throw new Error(\n        'overrideTemplate is not supported in this implementation of TestComponentBuilder.');\n  }\n\n  /**\n   * Overrides a component's {@link ViewMetadata}.\n   */\n  overrideView(componentType: Type, view: ViewMetadata): TestComponentBuilder {\n    throw new Error(\n        'overrideView is not supported in this implementation of TestComponentBuilder.');\n  }\n\n  /**\n   * Overrides the directives from the component {@link ViewMetadata}.\n   */\n  overrideDirective(componentType: Type, from: Type, to: Type): TestComponentBuilder {\n    throw new Error(\n        'overrideDirective is not supported in this implementation of TestComponentBuilder.');\n  }\n\n  /**\n   * Overrides one or more injectables configured via `providers` metadata property of a directive\n   * or\n   * component.\n   * Very useful when certain providers need to be mocked out.\n   *\n   * The providers specified via this method are appended to the existing `providers` causing the\n   * duplicated providers to\n   * be overridden.\n   */\n  overrideProviders(type: Type, providers: any[]): TestComponentBuilder {\n    throw new Error(\n        'overrideProviders is not supported in this implementation of TestComponentBuilder.');\n  }\n\n  /**\n   * Overrides one or more injectables configured via `providers` metadata property of a directive\n   * or\n   * component.\n   * Very useful when certain providers need to be mocked out.\n   *\n   * The providers specified via this method are appended to the existing `providers` causing the\n   * duplicated providers to\n   * be overridden.\n   */\n  overrideViewProviders(type: Type, providers: any[]): TestComponentBuilder {\n    throw new Error(\n        'overrideViewProviders is not supported in this implementation of TestComponentBuilder.');\n  }\n\n  overrideAnimations(componentType: Type, animations: AnimationEntryMetadata[]):\n      TestComponentBuilder {\n    throw new Error(\n        'overrideAnimations is not supported in this implementation of TestComponentBuilder.');\n  }\n\n  protected createFromFactory<C>(ngZone: NgZone, componentFactory: ComponentFactory<C>):\n      ComponentFixture<C> {\n    let rootElId = `root${_nextRootElementId++}`;\n    var testComponentRenderer: TestComponentRenderer = this._injector.get(TestComponentRenderer);\n    testComponentRenderer.insertRootElement(rootElId);\n\n    var componentRef = componentFactory.create(this._injector, [], `#${rootElId}`);\n    let autoDetect: boolean = this._injector.get(ComponentFixtureAutoDetect, false);\n    return new ComponentFixture<any /*C*/>(componentRef, ngZone, autoDetect);\n  }\n\n  /**\n   * Builds and returns a ComponentFixture.\n   */\n  createAsync<T>(rootComponentType: ConcreteType<T>): Promise<ComponentFixture<T>> {\n    let noNgZone = IS_DART || this._injector.get(ComponentFixtureNoNgZone, false);\n    let ngZone: NgZone = noNgZone ? null : this._injector.get(NgZone, null);\n    let compiler: Compiler = this._injector.get(Compiler);\n\n    let initComponent = () => {\n      let promise: Promise<ComponentFactory<any>> =\n          compiler.compileComponentAsync(rootComponentType);\n      return promise.then(componentFactory => this.createFromFactory(ngZone, componentFactory));\n    };\n\n    return ngZone == null ? initComponent() : ngZone.run(initComponent);\n  }\n\n  createFakeAsync<T>(rootComponentType: ConcreteType<T>): ComponentFixture<T> {\n    let result: any /** TODO #9100 */;\n    let error: any /** TODO #9100 */;\n    PromiseWrapper.then(\n        this.createAsync(rootComponentType), (_result) => { result = _result; },\n        (_error) => { error = _error; });\n    tick();\n    if (isPresent(error)) {\n      throw error;\n    }\n    return result;\n  }\n\n  createSync<T>(rootComponentType: ConcreteType<T>): ComponentFixture<T> {\n    let noNgZone = IS_DART || this._injector.get(ComponentFixtureNoNgZone, false);\n    let ngZone: NgZone = noNgZone ? null : this._injector.get(NgZone, null);\n    let compiler: Compiler = this._injector.get(Compiler);\n\n    let initComponent = () => {\n      return this.createFromFactory(\n          ngZone, this._injector.get(Compiler).compileComponentSync(rootComponentType));\n    };\n\n    return ngZone == null ? initComponent() : ngZone.run(initComponent);\n  }\n/** @nocollapse */\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: {type: Function, decorators?: DecoratorInvocation[]}[] = [\n{type: Injector, },\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}