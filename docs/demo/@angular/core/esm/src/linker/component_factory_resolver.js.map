{"version":3,"file":"component_factory_resolver.js","sourceRoot":"","sources":["../../../../../../modules/@angular/core/src/linker/component_factory_resolver.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;OAGI,EAAC,aAAa,EAAC,MAAM,sBAAsB;OAC3C,EAAe,SAAS,EAAC,MAAM,gBAAgB;AAKtD;;GAEG;AACH,6CAA6C,aAAa;IACxD,YAAmB,SAAmB;QACpC,MAAM,kCAAkC,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QAD/C,cAAS,GAAT,SAAS,CAAU;IAEtC,CAAC;AACH,CAAC;AAED;IACE,uBAAuB,CAAI,SAAoC;QAC7D,MAAM,IAAI,uBAAuB,CAAC,SAAS,CAAC,CAAC;IAC/C,CAAC;AACH,CAAC;AAED;;GAEG;AACH;AAGA,CAAC;AAFQ,6BAAI,GAA6B,IAAI,6BAA6B,EAAE,CAE5E;AAED;IAGE,YAAY,SAAkC,EAAU,OAAiC;QAAjC,YAAO,GAAP,OAAO,CAA0B;QAFjF,eAAU,GAAG,IAAI,GAAG,EAA8B,CAAC;QAGzD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1C,IAAI,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QACtD,CAAC;IACH,CAAC;IAED,uBAAuB,CAAI,SAAoC;QAC7D,IAAI,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAC5C,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,SAAS,CAAC,CAAC;QAC3D,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;AACH,CAAC;AAAA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, OpaqueToken, Optional, SkipSelf} from '../di';\nimport {BaseException} from '../facade/exceptions';\nimport {ConcreteType, stringify} from '../facade/lang';\n\nimport {ComponentFactory} from './component_factory';\n\n\n/**\n * @stable\n */\nexport class NoComponentFactoryError extends BaseException {\n  constructor(public component: Function) {\n    super(`No component factory found for ${stringify(component)}`);\n  }\n}\n\nclass _NullComponentFactoryResolver implements ComponentFactoryResolver {\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    throw new NoComponentFactoryError(component);\n  }\n}\n\n/**\n * @stable\n */\nexport abstract class ComponentFactoryResolver {\n  static NULL: ComponentFactoryResolver = new _NullComponentFactoryResolver();\n  abstract resolveComponentFactory<T>(component: ConcreteType<T>): ComponentFactory<T>;\n}\n\nexport class CodegenComponentFactoryResolver implements ComponentFactoryResolver {\n  private _factories = new Map<any, ComponentFactory<any>>();\n\n  constructor(factories: ComponentFactory<any>[], private _parent: ComponentFactoryResolver) {\n    for (let i = 0; i < factories.length; i++) {\n      let factory = factories[i];\n      this._factories.set(factory.componentType, factory);\n    }\n  }\n\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    let result = this._factories.get(component);\n    if (!result) {\n      result = this._parent.resolveComponentFactory(component);\n    }\n    return result;\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}